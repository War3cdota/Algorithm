# ArithmeticofTwoIntegers

## SubofTwoIntegers
### 方法一：通过加法实现
>减一个数等于加一个数的相反数，相反数的求法，取~（按位取反）再加一！

### 方法二：直接通过位操作实现减法
><font color="orange">1. 如果减数为0，则被减数即为减法的结果，运算结束。<br>
>    `if(b==0) return a;`<br>
2. 如果减数不为0，我们可以先把被减数和减数上同为1的位从两个数上去除。至于如何分离出值同为1的位，则可以通过求位与操作来做到；而把这些1分别中被减数和减数中去除，则可以通过按位异或来的操作来实现。<br>
>
	 	int sameBits = a&b;
		a ^= sameBits;
		b ^= sameBits;
>经步骤1处理后，被减数和减数在对应的位上，将或者通为0，或者分别为0和1，却不会同为1。<br>
>3. 此时：<br>
如果对应位被减数=1，而减数=0，则所得结果对应位也为1；<br>
如果对应位被减数=0，而减数=1，则所得结果对应位还是1，但此时须向前一位借1；<br>
即，通过被减数与减数作位异或（`^`）的操作得到临时结果，和通过对被减数左移一位得到需从临时结果中减去的借数。<br>
于是，经过步骤2后，原来的减法变成了要求：临时结果 - 借数<br>
很明显，只要以临时结果为被减数，借数为减数，重复步骤1~3即可。<br></font>

## MulofTwoIntegers（乘）

>二进制的乘法与十进制原理类似：都是将乘数的每一位和被乘数的每一位依次相乘，然后将相乘的结果相加即可。

![](http://i.imgur.com/VQ3OeSK.png)

>可以看出，乘法过程：如果乘数b的第i（i >= 1；i = 1是乘数最右侧的那一位）位为1，那么该位与被乘数a相乘的结果S[i]就是(a << i)；然后将这些所有的结果S[i]相加即为最后结果。

##DivofTwoIntegers（除）

![](http://i.imgur.com/oYhg0O1.png)

1. 先向左移位除数，直到除数成为移位中最大的小于被除数的数。记录移位次数。
2. 循环移位次数，如果被除数小于除数，则商位是1。